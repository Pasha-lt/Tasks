# моя почта 9139136@gmail.com
# B. A и B и ошибки компиляции
# A и B готовятся к олимпиадам про программированию.
# B очень любит отлаживать свой код. Но перед тем, как запустить решение и начать отладку, код нужно сначала скомпилировать.
# Изначально компилятор выдавал n ошибок компиляции, каждая из которых обозначается положительным целым числом.
# После некоторых усилий, B удалось исправить сначала одну, а потом еще одну ошибку.
# Однако, несмотря на то, что B уверен, что исправил две ошибки, он не может понять, какие именно ошибки компиляции исчезли — компилятор языка,
# на котором пишет B, каждый раз выдает ошибки в новом порядке! B уверен, что в отличие от многих других языков программирования,
# ошибки компиляции для его языка программирования не зависят друг от друга, т. е. от исправления одной ошибки,
# множество остальных ошибок не изменяется. А вы можете помочь B узнать, какие именно две ошибки он исправил?
# Входные данные
# Первая строка входных данных содержит целое число n (3 ≤ n ≤ 105) — изначальное количество ошибок компиляции.
# Вторая строка содержит n целых чисел через пробел a1, a2, ..., an (1 ≤ ai ≤ 109) — номера ошибок,
# выданных компилятором в первый раз. Третья строка содержит n - 1 целых чисел через пробел b1, b2, ..., bn - 1 — номера ошибок,
# выданных при второй компиляции. Гарантируется, что последовательность в третьей строке содержит все числа второй строки,
# за исключением ровно одного. Четвертая строка содержит n - 2 целых чисел через пробел с1, с2, ..., сn - 2 — номера ошибок,
# выданных при третьей компиляции. Гарантируется, что последовательность в четвертой строке содержит все числа третьей строки,
# за исключением ровно одного.
# Выходные данные
# Выведите два числа на отдельной строке: номера ошибок компиляции, исчезнувших после того как B внёс первое и второе исправление соответственно.
# Примеры
# входные данные
# 5
# 1 5 8 123 7
# 123 7 5 1
# 5 1 7
# выходные данные
# 8
# 123
# входные данные
# 6
# 1 4 3 3 5 7
# 3 7 5 4 3
# 4 3 7 5
# выходные данные
# 1
# 3
# Примечание
# В первом тестовом примере в первый раз B исправляет ошибку с номером 8, во второй — с номером 123.
# Во втором тестовом примере в первый раз B исправляет ошибку с номером 1, во второй — с номером 3. Обратите внимание,
# что если имеются несколько ошибок с одинаковым номером, за один раз B может исправить только одну из них.
# ------ solution ------


def main():
    a = map(int,input('Enter the number of errors'))
    b = list(map(int,input('Enter the result of the first compilation__').split()))
    c = list(map(int,input('Enter the result of the second compilation__').split()))
    d = list(map(int,input('Enter the result of the third compilation__').split()))
    foo(b,c,d)


def foo(b,c,d):
#Так как у нас добавляется только один элемент то вычислении разницы сумм мы его и получим.
#Таким образом мы можем решить задачу проще и с использованием меньшего количества данных(чем указано в ТЗ).
    print(sum(b) - sum(c))
    print(sum(c) - sum(d))
    main()


if __name__ == '__main__':
    main()
