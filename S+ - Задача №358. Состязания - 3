# Задача №358. Состязания - 3
# В метании молота состязается n спортcменов. Каждый из них сделал m бросков. Побеждает спортсмен,
# у которого максимален наилучший бросок. Если таких несколько, то из них побеждает тот,
# у которого наилучшая сумма результатов по всем попыткам. Если и таких несколько,
# победителем считается спортсмен с минимальным номером. Определите номер победителя соревнований.
# Входные данные
# Программа получает на вход два числа n и m, являющиеся числом строк и столбцов в массиве.
# Далее во входном потоке идет n строк по m чисел, являющихся элементами массива.
# Выходные данные
# Программа должна вывести одно число - номер победителя соревнований. Не забудьте, что  строки  (спортсмены) нумеруются с 0.
# Примеры
# входные данные
# 3 3
# 1 2 7
# 1 3 5
# 4 1 6
# выходные данные
# 0


a = []
def make_matrix():
    """
    Функция  принимает данные и на основе этих данных создает таблицу с результатами и передает их в функцию foo()
    или bar(). Функция bar() более примитивна, но она позволят определить победителя не имея стартовых данных
    о количестве попыток игроков и дает возможность вводить их в моменте их совершения.
    n - Количество игроков.
    m - Количество подхожов каждого играка.
    """
    n, m = map(int, input('==>').split())
    for i in range(n):
        a.append(list(map(int, input().split())))
    foo(n, m, a)
    bar(a)


def foo(n, m, a):
    """
    Функция определяет победителя.
    max_score - Максимальное количество попаданий за один раз.
    max_sum - Количество набраных очков одним игроком.
    person - Порядковый номер игрока.
    :param n: - Количество игроков.
    :param m: - Количество подхожов каждого играка.
    :param a: - табличка с результатами (матрица из вложенных списков).
    """
    max_score = 0
    max_sum = 0
    person = 0

    for row in range(n):
        max_try = 0
        s = 0
        for column in range(m):
            s += a[row][column]
            if a[row][column]>max_try:
                max_try = a[row][column]
        if max_try > max_score:  # Если у одного максимальное количество попаданий за один раз.
            max_score = max_try
            max_sum = s
            person = row  # Так как у нас вложеные списки то row и будет порядковыя номером играка.
        elif max_try == max_score and s>max_sum:  # В случае когда у нескольких игроков одинаковый max_score
            max_score = max_try
            max_sum = s
            person = row

    print(person)


def bar(a):
    """
    Функция определяет победителя.
    :param a: - табличка с результатами (матрица из вложенных списков)
    """
    if max(a[1]) < max(a[0]) > max(a[2]):
        print(0)
    elif max(a[0]) < max(a[1]) > max(a[2]):
        print(0)
    elif max(a[1]) < max(a[2]) > max(a[0]):
        print(2)

    elif sum(a[1]) < sum(a[0]) > sum(a[2]):
        print(0)
    elif sum(a[0]) < sum(a[1]) > sum(a[2]):
        print(1)
    elif sum(a[1]) < sum(a[2]) > sum(a[0]):
        print(2)

    elif sum(a[1]) == sum(a[0]) == sum(a[2]):
        print(0)
    elif sum(a[0]) == sum(a[1]):
        print(0)
    elif sum(a[0]) == sum(a[2]):
        print(0)
    elif sum(a[1]) == sum(a[2]):
        print(1)
    else:
        print('error')


if __name__ == '__main__':
    make_matrix()
